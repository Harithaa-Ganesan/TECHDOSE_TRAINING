Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.

 

Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
 
 SOLUTION:
 
 import java.io.IOException;
import java.util.*;

public class Node {
    int key;
    int value;
    Node prev;
    Node next;

    public Node(int k, int v){
        this.key = k;
        this.value = v;
        this.prev = null;
        this.next = null;
    }

    public void setNext(Node n){
        this.next = n;
    }
    public void setPrev(Node n){
        this.prev = n;
    }

    public Node getNext(){
        return this.next;
    }

    public Node getPrev(){
        return this.prev;
    }

    public boolean equals(Object o) { 
        // If the object is compared with itself then return true 
        if (o == this) {
            return true;
        }     
        /* Check if o is an instance of Element or not
          "null instanceof [type]" also returns false */
        if (!(o instanceof Node)) {
            return false;
        }             
        // typecast o to Element so that we can compare data members
        Node c = (Node) o;
        return (c.key == key && c.value == value);       
    }
}


class LRUCache {
    private static Map<Integer, Node> map;
    int capacity = 0;
    Node head = null;
    Node tail = null;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        LRUCache.map = new Hashtable<Integer,Node> (capacity);
    }
    
    public int get(int key) {
            // This has O(n) complexity due to bringin the element to top of the queue.
            if (LRUCache.map.containsKey(key)){
                if (LRUCache.map.size() == 1){
                    return head.value;
                }
                setHead(new Node(key, LRUCache.map.get(key).value));
                removeNode(LRUCache.map.get(key));
                LRUCache.map.put(key, head);   
                return head.value;
            } 
            return -1;
    }

    public void removeNode(Node n){
        // only one node
        if (head == tail){
            head = tail = null;
            return;
        }
        // n is the tail node
        if ( n.equals(tail)){
            tail = n.getPrev();
            if (tail != null)
                tail.setNext(null);
            n = null;
            return;
        }
        // n is the center node
        n.getPrev().setNext(n.getNext());
        n.getNext().setPrev(n.getPrev());
        n = null;
    }

    public void setHead(Node t){
        t.setNext(head);
        if (head != null)
            head.setPrev(t);
        if (tail == null)
            tail = t;
        head = t;
    }
    
    public void put(int key, int value) {
            if (LRUCache.map.containsKey(key)){ // This has O(n) complexity due to bringin the element to top of the queue.
                Node t = LRUCache.map.get(key);
                if (t == head){
                    // Just set the new value & return
                    t.value = value;
                    return;
                }
                removeNode(t);
                setHead(new Node(key,value));
                LRUCache.map.put(key, head);
            } 
            else if (LRUCache.map.size() < capacity){ // add to the queue & Map. O(1)
                if (head == null && tail == null){
                    head = tail = new Node(key, value);    
                }
                else{
                    setHead(new Node(key,value));
                }
                LRUCache.map.put(key,head);
            }
            else{ // Queue full. Evict the least used element & add this one. No change in size. O(1)
                LRUCache.map.remove(tail.key);
                removeNode(tail);
                setHead(new Node(key,value));
                LRUCache.map.put(key,head);
            }
    }

}
